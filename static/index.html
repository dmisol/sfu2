<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="stylesheet" type="text/css" href="styles.css" />
</head>

<body>
    <div id="select_ftar">
        <H1>Please select one of our recent flexatars to be used for animating.</H1>
        <br>
        <H2>To create your own flexatar please use our IOS TestFlight. The result will appear here almost immediately.
        </H2>
        <br>
    </div>

    <div id="change_browser" style="display: none;">
        <H1>Please change your browser. For the demo, we are expecting either Chrome or Safari</H1>
    </div>

    <div id="mode_select" style="display: none;">
        <div> <b>
                Now you can either
                <p>
                    <button type="button" onclick="window.main()">Participate in WebRTC conference with other
                        humans</button>

                </p>
                <div>
                    or <button type="button" disabled onclick="window.Bot()">Talk to a ChatGPT-powered bot </button>
                </div>
            </b>
        </div>

        <i>
            <p>
                The animating and rendering procedures are light-weighted and can be performed in browser.
            </p>
            <p>
                Once upon a time we are planning to implement it with WebGL.
            </p>
        </i>
        <div> <i>
                Sources of this demo are here:
                <a href="https://github.com/dmisol/sfu2">github.com/dmisol/sfu2</a>
            </i>
        </div>
    </div>

    <video id="localVideo" width="160" height="120" autoplay muted style="display: none;"></video>
    <div id="upVideos" style="display: flex"></div>
    <div id="dwnVideos" style="display: flex"></div>
</body>

<script>
    var ftar = "random";
    const up = document.getElementById("upVideos");
    const dwn = document.getElementById("dwnVideos");
    let cntr = 0;
    let bot = 0;
    const modeSelect = document.getElementById("mode_select");

    select_ftar();
    function check_browser() {
        let userAgent = navigator.userAgent;

        console.log(userAgent);
        if (userAgent.match(/chrome|chromium|crios/i)) {
            return 1;
        }
        if (userAgent.match(/safari/i)) {
            return 1;
        }
        document.getElementById('select_ftar').style.display = 'none';
        document.getElementById('change_browser').style.display = 'flex';
    }

    function select_ftar() {
        if (!check_browser()) return;

        const p = document.getElementById("select_ftar");
        fetch('icon/list', {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
            },
        })
            .then(response => response.json())
            .then(response =>
                response.forEach((key) => displayIcon(p, key))
            )
    }

    function displayIcon(p, key) {
        let img = document.createElement('img');
        img.src = "icon/" + key;
        img.onerror = function handleError() {
            console.log('Image could not be loaded' + key);
            img.style.display = 'none';
        };
        img.onclick = function continueWithFlexatar() {
            ftar = key;
            p.style.display = 'none';
            modeSelect.style.display = 'block';
        };
        p.appendChild(img);
    }

    function Bot() {
        bot = 1;
        main();
    }
    function main() {
        modeSelect.style.display = 'none';

        navigator.mediaDevices.getUserMedia({
            video: false,
            audio: true
        })
            .then(stream => {
                let pc = new RTCPeerConnection()
                pc.ontrack = function (event) {
                    console.log("stream " + stream.id + " add " + event.track.kind + "-->" + event.track.id)
                    // TODO: mark somehow audio-only streams if occur 
                    /*
                    if (event.track.kind === 'audio') {
                        return
                    }
                    */

                    let el = document.createElement(event.track.kind)
                    el.srcObject = event.streams[0]
                    el.autoplay = true
                    el.controls = true
                    el.setAttribute('playsinline', '')
                    el.setAttribute('class', "bg_div" + cntr)
                    cntr++;
                    if (cntr >= 10) cntr = 0;

                    if (event.track.kind === 'audio') {
                        el.style.display = 'none';
                        document.getElementById("start").appendChild(el)
                    } else {
                        if (up.childNodes.length > dwn.childNodes.length) dwn.appendChild(el)
                        else up.appendChild(el)
                    }

                    event.track.onmute = function (event) {
                        el.play()
                    }

                    event.streams[0].onremovetrack = ({
                        track
                    }) => {
                        if (el.parentNode) {
                            el.parentNode.removeChild(el)
                        }
                    }
                }
                pc.onremovetrack = function (event) {
                    console.log("rem" + event.track.kind + "-->" + event.track.id)
                }

                document.getElementById('localVideo').srcObject = stream
                stream.getTracks().forEach(track => pc.addTrack(track, stream))

                var loc = window.location,
                    uri;

                if (loc.protocol === "https:") {
                    uri = "wss:";
                } else {
                    uri = "ws:";
                }
                uri += "//" + loc.host + "/ws?ftar=" + ftar;
                if (bot) uri += "&bot=true";
                let ws = new WebSocket(uri)
                pc.onicecandidate = e => {
                    if (!e.candidate) {
                        return
                    }

                    ws.send(JSON.stringify({
                        event: 'candidate',
                        data: JSON.stringify(e.candidate)
                    }))
                }

                ws.onclose = function (evt) {
                    window.alert("Websocket has closed")
                }

                ws.onmessage = function (evt) {
                    let msg = JSON.parse(evt.data)
                    if (!msg) {
                        return console.log('failed to parse msg')
                    }

                    switch (msg.event) {
                        case 'offer':
                            let offer = JSON.parse(msg.data)
                            if (!offer) {
                                return console.log('failed to parse answer')
                            }
                            //console.log("got offer:")
                            //console.log(offer.sdp)

                            pc.setRemoteDescription(offer)
                            pc.createAnswer().then(answer => {
                                pc.setLocalDescription(answer)
                                ws.send(JSON.stringify({
                                    event: 'answer',
                                    data: JSON.stringify(answer)
                                }))

                                //console.log(" sent answer:")
                                //console.log(answer)
                            })
                            return

                        case 'candidate':
                            let candidate = JSON.parse(msg.data)
                            if (!candidate) {
                                return console.log('failed to parse candidate')
                            }

                            pc.addIceCandidate(candidate)
                    }
                }

                ws.onerror = function (evt) {
                    console.log("ERROR: " + evt.data)
                }
            }).catch(window.alert)
    }
</script>

</html>